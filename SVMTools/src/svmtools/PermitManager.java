package svmtools;

import java.security.PrivateKey;
import java.io.*;
import java.util.Hashtable;
import java.util.Enumeration;

/**
 * This class centralises the handling of permits for Trusted classes. This
 * includes both servicing permit requests as well as reading in a set of permits
 * and making them available to the Wobulator. That is, this class manages a
 * database of permits. All the permits in a given database must be of the
 * same type. That is, they must all have been generated by the same CSP.
 *
 * Permits are similiar to X.509 public key certificates. The primary difference
 * is that certificates encapsulate public keys where as permits encapsulate
 * digital signatures. The digital signature in a permit is the concrete
 * representation of a privilege granted from one class (the "grantor") to
 * another class (the "grantee"). The two types of privileges currently defined
 * are the subclassing privilege and the instantiation privilege. See the SVM
 * documentation for further descriptions of these privileges.
 */

public class PermitManager {

    // ---------------------- Permit class -----------------------------------

    /**
     * This class defines the contents of a permit entry in the permit database.
     * It also includes methods for serializing an entry as well as
     * reconstructing a serialized entry.
     */
    static public class Permit implements Cloneable, Comparable {

        public static final String SUBCLASS = "subclass";
        public static final String CLASS_RESOURCE_ACCESS = "class resource access";

        /**
         * The signature of the class that granted the permit.
         */
        final public String grantor;

        /**
         * The signature of the class to which the permit was granted.
         */
        final public String grantee;

        /**
         * The type of the permit. Must be one of the constants
         * SUBCLASS or CLASS_RESOURCE_ACCESS.
         */
        final public String type;

        /**
         * The signature implementing the permit.
         */
        private byte signature[];

        /**
         * Serialize to data stream.
         */
        public void serialize(DataOutputStream out) throws IOException {
            out.writeUTF(grantor);
            out.writeUTF(grantee);
            out.writeUTF(type);
            // Write out the length of the signature.
            if (signature.length >= Short.MAX_VALUE)
                throw new IOException("signature is too long");
            out.writeShort(signature.length);
            out.write(signature);
        }

        /**
         * Construct from serialized form.
         */
        public Permit(DataInputStream in) throws IOException {
            grantor = in.readUTF();
            grantee = in.readUTF();
            type = in.readUTF();
            int length = in.readUnsignedShort();
            if (length >= Short.MAX_VALUE)
                throw new IOException("signature is too long");
            signature = new byte[length];
            in.read(signature);
        }

        /**
         * Convenience constructor to set all field values.
         */
        public Permit(String grantor, String grantee, String type, byte sig[]) {
            this.grantor = grantor;
            this.grantee = grantee;
            this.type = type;
            this.signature = sig;
        }

        /**
         * Copy constructor.
         */
        public Permit(Permit p) {
            this.grantor = p.grantor;
            this.grantee = p.grantee;
            this.type = p.type;
            this.signature = (byte[])p.signature.clone();
        }

        /**
         * Return a copy the signature.
         */
        public byte[] getSignature() {
            return (byte[])signature.clone();
        }

        /**
         * Return the key parts of the permit as a String.
         */
        public String toString() {
            return toString(false);
        }
        public String toString(boolean includeSignature) {
            StringBuffer buf = new StringBuffer(100);
            buf.append("grantee=");
            buf.append(grantee);
            buf.append(",grantor=");
            buf.append(grantor);
            buf.append(",type=");
            buf.append(type);
            if (includeSignature) {
                buf.append(",signature=");
                for (int i = 0; i != signature.length; i++)
                    buf.append(Integer.toHexString(signature[i]&0xFF)+" ");
            }
            return buf.toString();
        }

        public int compareTo(Object o) throws ClassCastException {
            if (!(o instanceof Permit))
                throw new ClassCastException();
            return toString().compareTo(o.toString());
        }

        /**
         * The following 3 methods simplify use of Permits with the
         * java.util.Collection based classes.
         */
        public String asKey() {
            return grantor+grantee+type;
        }
        public boolean equals(Object o) {
            if (!(o instanceof Permit))
                return false;
            Permit p = (Permit)o;
            return grantor.equals(p.grantor) &&
                   grantee.equals(p.grantee) &&
                   type.equals(p.type);
        }
        public int hashCode() {
            return (grantor + grantee + type).hashCode();
        }
        public Object clone() {
            Permit p = null;
            try {
                p = (Permit)super.clone();
            } catch (CloneNotSupportedException cnse) {
                // Will never happen
            }
            p.signature = (byte[])signature.clone();
            return p;
        }
    }

    // --------------------------- Fields -------------------------------------

    /**
     * The CSP used to generate permits and verify existing permits.
     */
    CSP csp;

    /**
     * The permit database.
     */
    Hashtable permits = new Hashtable(111);

    // --------------------------- Methods ------------------------------------

    /**
     * Merge in the contents of a serialized permits database.
     * @param in The serialized database.
     * @param overwrite if true, permits from in overwrite existing permits in
     * the case of a conflict
     */
    public void load(DataInputStream in, boolean overwrite) throws IOException {
        int count = in.readInt();
        if (count < 0)
            throw new IOException("corrupt database");
        // The remaining data is permits
        do {
            Permit entry = new Permit(in);
            String key = entry.asKey();
            if (overwrite || !permits.containsKey(key))
                permits.put(key,entry);
        } while (in.available() != 0);
        // An exception will already have been thrown if the database did
        // not end on a permit boundary.
    }

    /**
     * Construct an empty database.
     */
    public PermitManager() {
    }

    /**
     * Return set of permits matching a given grantee.
     * @param grantee The grantee to search on.
     * @return a copy of the permits in the database whose grantee field matches
     * grantee.
     */
    public Hashtable getPermitsByGrantee(String grantee) {
        Hashtable matches = new Hashtable(permits.size());
        for (Enumeration e = permits.elements(); e.hasMoreElements(); ) {
            Permit permit = (Permit)e.nextElement();
            if (permit.grantee.equals(grantee))
                matches.put(permit.asKey(),permit.clone());
        }
        return matches;
    }

    /**
     * Serialize to an output stream.
     */
    public void serialize(DataOutputStream out) throws IOException {
        out.writeInt(permits.size());
        for (Enumeration e = permits.elements(); e.hasMoreElements();) {
            Permit p = (Permit)e.nextElement();
            p.serialize(out);
        }
    }

    /**
     * Service a permit request. The request is given as a partially complete
     * Permit object that has values for all but the signature field as well as
     * a CSP and key used to generate this signature.
     * @param p The permit to complete.
     * @param csp The CSP to use for the signing.
     * @param key The private key to be used when signing.
     * @param addToDB if true, a copy (clone) of the completed permit is added
     * to the database maintained by this PermitManager object, replacing
     * any existing permit with an equal value (as determined by Permit.equals).
     * @param cp the Classpath to search for the class in the permit.
     * @return the completed Permit.
     */
    public Permit servicePermitRequest(Permit p, CSP csp, PrivateKey key,
        boolean addToDB, ClassPath cp) throws CSPException, IOException
    {
       ClassFile cf = cp.getFile(p.grantee.replace('.',File.separatorChar) + ".class");
        if (cf == null)
            throw new FileNotFoundException("can't find class "+p.grantee);
        InputStream is = cf.getInputStream();
        byte class_file[] = new byte[is.available()];
        is.read(class_file);
        p.signature = csp.sign(class_file,key);
        if (addToDB)
            addPermit(p,true);
        return p;
    }

    /**
     * Add a permit to the database.
     * @param p The permit to add.
     * @param overwrite if true then force the addition, overwriting any
     * existing permit of the same value
     * @return true if there was already a permit equivalent to p in the database
     * prior to invoking this method.
     */
    public boolean addPermit(Permit p, boolean overwrite) {
        String key = p.asKey();
        boolean exists = permits.containsKey(key);
        if (!exists || overwrite)
            permits.put(key,p);
        return exists;
    }
}
