
% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.2 for LaTeX2e
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
\addtocmark{A Mechanism for Secure, Fine-Grained Dynamic Provisioning of Applications on Small Devices} % additional mark in the TOC
%
%
\tableofcontents
%
\mainmatter              % start of the contributions
%

% 
\renewcommand\labelitemi{$\bullet$}

%%%%%%%%%%%%% Definitions for this paper %%%%%%%%%%%%%%%%%%%

%%
%
%%
\renewcommand{\url}[1] {\texttt{#1}}

%%
% Define a table macro that creates tables centered on the page and whose rows
% are decently padded.
% 
% #1 - cross-referencing label of table
% #2 - caption for table
%%
\newenvironment{ctable}[2]%
{\begin{table}[h]%
 \newcommand{\lbl}{#1}%
 \newcommand{\cpt}{#2}%
 \renewcommand{\arraystretch}{1.5}%
 \begin{center}}%
{\end{center}%
 \vspace{1em}
 \caption{\cpt}
 \label{\lbl}%
 \end{table}}

%%
% specify formatting for a column in a table based on a given width in terms
% of percentage of the textwidth
%%
\newcommand{\col}[1] { @{\ \ }p{#1\textwidth}@{\ \ }}
\newcommand{\lcol} { @{\ \ }l@{\ \ }}
\newcommand{\rcol} { @{\ \ }r@{\ \ }}

%%
% format argument in like source code
%%
\newcommand{\src}[1] {\texttt{#1}}

%%
% format argument as a crypto key - 1st argument followed by subscripted 2nd
%%
\newcommand{\key}[2] {$\mbox{#1}_{#2}$}

%%
% format argument as a variable
%%
\newcommand{\var}[1] {$#1$}

\title{A Mechanism for Secure, Fine-Grained Dynamic Provisioning of Applications on Small Devices}
%
\titlerunning{Secure KVM}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{William R. Bush\inst{1} \and Antony Ng\inst{2}
Doug Simon\inst{1} \and Bernd Mathiske\inst{1}}
%
\authorrunning{William R. Bush et al.}   % abbreviated author list (for running head)
%
%%%% modified list of authors for the TOC (add the affiliations)
\tocauthor{William R. Bush, Doug Simon, Bernd Mathiske (Sun Microsystems Laboratories),
Antony Ng (D'Crypt Pte. Ltd.)}
%
\institute{Sun Microsystems Laboratories, Mountain View CA 94043, USA,\\
\email{bill.bush@sun.com},\\ WWW home page:
\url{http://research.sun.com/}
\and
D'Crypt Pte. Ltd}

\maketitle              % typeset the title of the contribution

\begin{abstract}
As small, secure devices become more powerful and more wide spread, it has become desirable
to support the dynamic provisioning and updating of multiple applications on such devices. This
paper presents a simple mechanism for performing such provisioning and updating, even if the
applications are mutually distrustful. The mechanism extends CLDC Java\texttrademark technology
with a classfile attribute that carries the certificates necessary to enable the added security.
\end{abstract}
%
\section{Background}
%
The work described here was motivated by a number of developments and considerations:
\begin{itemize}
  \item Small, secure devices, such as smart cards and cryptographic modules, are becoming more capable.
  \item Such devices are being used in more complex situations running multiple applications.
  \item Updating the software on such devices once deployed is highly desirable, to provide both new
  functionality and software fixes, but poses various security issues.
  \item A dynamic provisioning mechanism supporting such activity should be small and simple,
  because of device limitations and to aid in verification and certification.
  \item The Java platform has appeared on small devices and provides dynamic class loading and
  some basic security features.
\end{itemize}
The resulting solution presented here:

\begin{itemize}
  \item supports the secure incremental replacement and extension of software
  on small devices,
	\item  enables distinct trust communities developing
	distinct applications,
  \item accomplishes this by extending a common version of the Java platform, and
  \item enables	additional support for capabilities and running untrusted	code.
\end{itemize}

\section{The Java Context}

The Java platform was the starting point for this investigation
because it already provides various features supporting security
and dynamic provisioning. Unlike C and C++, for example, it guarantees
type and pointer safety. Various Java versions provide different
forms of application isolation. And all versions support some
mechanism for dynamically installing classes.

\subsection{The Connected Limited Device Configuration}

The work described here is specifically aimed at the next generation
of smart cards and other similar small devices. Thus the technology
base used is the Connected Limited Device Configuration (CLDC)
version of Java 2 Platform, Micro Edition (J2ME\texttrademark technology) \cite{cldc}.
This version of the Java platform is the smallest one that supports
most standard features of the Java language (in contrast to the
much more restrictive Java Card\texttrademark specification \cite{javacard}). It outlines
a basic set of libraries and Java virtual machine features. Compliance
with the CLDC specification is demonstrated by passing the CLDC
Technology Compatibility Kit (TCK) tests \cite{tck}.

The heart of the configuration is the K Virtual Machine (KVM) \cite{kvm}.
The KVM is a virtual machine designed with the constraints of small
devices in mind. Named to indicate that its size is measured in
tens of kilobytes, the KVM is simple, in order to minimize memory
footprint. This simplicity makes the KVM easy to understand and
modify, important characteristics in the context of security.

\subsection{CLDC Security}

The CLDC security model \cite[section 3.4]{cldc} defines three types of
security, low-level VM security, application-level security, and
end-to-end security.

Low-level VM security is defined as the characteristic that ``an
application must not be able to harm the device in which it is
running, or crash the virtual machine itself.'' In the context of
the KVM this means that CLDC verification must be done on all
classfiles.

End-to-end security refers to network-based solution-oriented
security, which is outside the scope of the CLDC specification.

Application-level security is defined as controlling access to
external resources, which is done on the larger J2SE~\texttrademark platform by
the security manager \cite{j2ps}. The security manager was deemed to
have too large a memory footprint for the CLDC, so a sandbox model
is used instead. Specifically:

\begin{itemize}
  \item Only a limited set of APIs is available (the CLDC
	libraries, profiles, and manufacturer-specific classes).
  \item  Such system classes cannot be overridden.
  \item No user-defined class loaders are allowed.
  \item No native functions can be dynamically loaded onto the device.
  \item The class lookup order may not be manipulated.
  \item By default, an application may only load classes from its own JAR file.
  \item In addition, a CLDC implementation need not support multiple concurrent applications.
\end{itemize}

The CLDC security model is a good starting point for a more secure
platform. It is small, simple, and relatively static, which is good
both for small devices and for increased security. It has a static
set of APIs, system classes, and native functions, and a single
system class loader. It has a simple application model. It is
possible to be compliant with the CLDC and provide greater security
than the CLDC mandates.

\subsection{MIDP Security}


The Mobile Information Device Profile (MIDP) [MIDP] is a set of
additions to the base CLDC platform that supports mobile phones.
Among the additions is a security mechanism \cite{kolsi}, \cite{knudsen}.
The MIDP security mechanism is based on two concepts: protection domains and
JAR file signing.

A protection domain is a set of permissions granted an application,
and defines the application's sandbox (see \cite{acharya} and \cite{peterson}
for descriptions
of nuanced sandboxes). An application runs in a single protection
domain. A MIDP platform may define various domains, but required
domains include Manufacturer, Operator, Third-Party, and Untrusted.
Some permissions may only be granted through interaction with the
user of the device (confirming use of the permission).

JAR file signing is used to verify the authenticity of an application.
MIDP requires that an application reside in a single JAR file, which
is typically signed using X.509 PKI infrastructure, support for
which is required by the MIDP standard. The MIDP device uses the
certificates it possesses to authenticate the application.

This security model has limitations with respect to high security
devices. Specifically:
\begin{itemize}
  \item Permissions are coarse grained and set when the	device is manufactured.
  A set of permissions is \emph{a priori} bound to a domain, and an entire application
  then executes in one of those predefined domains.
  \item Support for X.509 PKI is required, which may not be appropriate and can
  be cumbersome.
  \item User interaction may be required to grant some permissions.
\end{itemize}

In sum, the MIDP platform has been carefully tuned for mobile phones.
High security devices are different.

\subsection{Compatibility and Security Goals}

The broad goal of this work is to develop a more secure version of
the KVM (the Secure KVM, or SKVM), with a particular focus on dynamic
provisioning. More specifically:
\begin{itemize}
  \item Correct CLDC/KVM applications should not be able to distinguish
  the KVM from the SKVM on the basis of observed behavior.
  \item Correctly implemented secure applications operating
  normally should not be able to distinguish the KVM from the
  SKVM on the basis of observed behavior.
  \item Only malicious classes should elicit different behavior from the
  SKVM than they would from the KVM.
  \item The SKVM must pass the proper compatibility tests (the CLDC TCK).
\end{itemize}

Additionally, the SKVM should be capable of being validated as
secure, specifically achieving FIPS 140-2 certification \cite{fips}.
FIPS 140-2 is a specification drawn up by the National Institute
of Standards and Technology, defining security requirements for
cryptographic modules. In addition to being the stipulated requirement
for any cryptographic module acquired by the US government, FIPS140-2
has become a de facto standard for cryptographic equipment and
provides a level of assurance that the equipment was designed with
adequate consideration of security. The standard spells out
requirements in 11 different areas including physical security,
hardware security, software security, and key management. A
cryptographic module can be certified to any of four increasing
levels of assurance. For example, the IBM 4758 has been certified
at the highest level (of the predecessor FIPS 140-1 standard) \cite{dyer}.

\section{Key Precepts}

A number of key precepts guided the design of the SKVM architecture
(see \cite{schneier}, \cite{schneier96}, \cite{anderson}).

\subsection{Simplicity}

The overriding precept is simplicity. It has several important
benefits:
\begin{itemize}
  \item It minimizes bugs and possible points of compromise.
  \item It keeps the system's memory footprint small.
  \item It makes the system easier for application developers to
  understand, which in turn makes it easier for them to
  implement secure applications.
  \item It makes the system easier to validate for security. Such validation typically
  involves modeling security state transitions with a state
  machine (this is the paradigm required for FIPS 140-2 certification).
\end{itemize}

\subsection{Fail-Safe Design}

When a fail-safe system encounters an unanticipated condition, it
always lapses into a conservative, secure state. Such conditions
can be genuinely unanticipated or can be a result of a partial
malfunction of the system. No matter how comprehensively a system
is analyzed, it is unlikely that all possible combinations of
conditions have been anticipated. Fail-safe design ensures that the
system makes conservative assumptions and lapses into a secure state
when an unanticipated condition is encountered.

A watchdog signal in a battery-powered system is an example of
fail-safe design. As long as periodic signals arrive from the
watchdog, the CPU continues normal operation. If the battery runs
low, the periodic watchdog signal is terminated, and the CPU shuts
down. Note that if the watchdog signal is interrupted in any other
way (for example, due to physical tampering), the CPU also shuts
down - it lapses into a secure state.

\subsection{Static Specification of Security Policy}

The ability to modify policy dynamically is usually considered a
desirable feature. For a secure device, it is also a major source
of weaknesses. Dynamic modification of security policy is almost
always a cause of subtle bugs. In contrast, a static security model
forces the application developer to consider the security aspects
of the software architecture earlier and more completely in the
design process. A static model is also in general easier to analyze
and vet because it is simpler and usually has fewer states and state
transitions than a dynamic model.

\subsection{Explicit Specification of Security}

The combination of static security specification and fail-safe
design dictates that security issues - specifically the granting
of privileges - involve an explicit act on the part of an object,
and that any privilege not explicitly granted is automatically
denied. The SKVM implements this precept within the confines of the
semantics of the Java programming language (hereinafter referred
to as the Language).

As an example of how the Language semantics affects this precept,
note that an object has the right to manipulate those parts of it
(including protected data) that are inherited from its ancestors.
When an object grants privileges to another object, through the
Language semantics it automatically and implicitly grants (some) access
to all its ancestors in the inheritance tree.

\subsection{Security at the VM Level}

Implementing security policy using only classes is attractive for
several reasons, including extensibility and uniformity. However,
good security engineering suggests that the core of the security
framework be implemented at the VM level. The challenge is to keep
the bare minimum in the VM level and leave as much as possible at
the language level so that a high level of security assurance can
be established without compromising system flexibility.

\subsection{Reliance on Data Authenticity, not Secrecy}

Secrets stored on a device, such as symmetric or private keys,
introduce potential vulnerabilities and complicate responses to
security compromises. They also complicate the device and increase
its cost since the device must now defend the secret against
disclosure. In contrast, use of verifiably authentic data, such as
certificates verifiable with public keys, does not create such
weaknesses.

The SKVM is designed so that security assurance relies only on the
ability of the device to keep data authentic. The SKVM does not
require the device to keep a secret.

\section{The SKVM Security Architecture}

This and following sections present the components of the SKVM
security architecture:
\begin{itemize}
  \item The notion of trust;
  \item The implementation of trust;
  \item The characteristics of other necessary VM features; and
  \item The application model.
\end{itemize}

\subsection{Owners, Trust Relationships, and the Trust Community}

In a well-designed, secure, closed system every class, interface,
and package - every component - has an owner, an entity (nominally
a human) with ultimate responsibility for it.

Systems are often assembled from components developed by different
owners. One owner may or may not trust another, based on their
relationship. Owners that do trust one another form a community,
however informally.

Components that are not part of a verifiable trust community are
untrusted, and are not allowed to execute (subject to an optional
feature discussed in Section~\ref{crypto-support}).

These basic observations are the foundation of the SKVM security
architecture. It implements these notions of \emph{ownership} and
\emph{trust} in the context of the CLDC.

\subsection{Trusted Classes}

The SKVM supports trust relationships and a trust community by
providing the framework and features necessary to request and grant
privileges. The SKVM itself maintains no explicit information on
trust relationships and trust communities other than what each class
brings in.

Intuitively, a trusted class is provided for some trusted community
of owners. Trusted classes are the means by which sensitive information
is encapsulated. Trusted classes also have privileges and can in
turn grant privileges to other trusted classes.

As mentioned earlier, a trusted class has an owner. It is the
responsibility of this owner to request and obtain the necessary
privileges for the trusted class. If class \var{X} needs a particular
privilege from class \var{Y}, the owner of class \var{X} will have to acquire
this privilege from the owner of the class \var{Y}. These privileges come
in the form of certificates signed by \var{Y}'s owner and held by class
\var{X}. They are verified by the SKVM when class \var{X} is loaded. In fact,
the difference between a trusted class and an untrusted class is
precisely this: a trusted class will carry with it certificates
that prove that it has certain privileges, while an untrusted class
has no such certificates, and will thus not be loaded by the SKVM.

All the certificates of a trusted class are bundled into a new class
attribute called a trust attribute. (Class attributes are the
classfile mechanism used to store extra information about a class,
and are described in the Java Virtual Machine Specification \cite[section 4.7]{jvms}.)

\subsection{Trusted Classes and the Privilege Hierarchy}

The SKVM is designed to support multiple application components
that may be mutually distrustful. Furthermore, while all classes
in an application may manage security properly, the architecture
should be fail-safe and contain any region of compromise.

Both these observations imply a need for varying degrees of trust,
even among trusted components. The SKVM supports a fine-grained
security model by controlling the installation of individual classes.
Specifically, the SKVM enforces a subclassing privilege that enables
one class to install itself as a subclass of another. In some sense
this privilege is the privilege to modify, in a controlled way, the
code on the device. It is referred to as the S privilege. Subclassing
also includes the power to access the protected fields, methods,
and constructors of all the superclasses of the subclassing class,
regardless of package.

Note that accesses to static and instance methods and fields are
controlled through the Language's private, protected, and public
tagging \cite[section 6.6]{jls}. Note that the Java Virtual Machine
Specification stipulates that accesses have to be checked at run
time \cite[sections 5.4.3 and 5.4.4]{jvms}. Information about private,
protected, and public access permissions are stored in the classfile
\cite[sections 4.5 and 4.6]{jvms} to enable such run time checking.

The S privilege enables a precise definition of a trust community.
Since all classes except \src{java.lang.Object} subclass some other
class, the class hierarchy tree rooted at \src{java.lang.Object} can be thought
of as defining a trust relationship that is transitively closed
downwards. More precisely, a \emph{trust community} is defined recursively
as follows:

\begin{itemize}
  \item \src{java.lang.Object} is a member of the trust community, and
  \item Any class that has requested and obtained the privilege to
  subclass a class in the trust community is itself a member
  of the trust community.
\end{itemize}

Thus \src{java.lang.Object} has a trust relationship; either directly or indirectly,
with all trusted classes.

Note that the ability to subclass a class does not imply the ability
to subclass any parent of the class in the class hierarchy
independently.

\subsection{Trusted Classes and Packages}

The Language employs the package construct to bundle groups of
classfiles, not necessarily related in the class hierarchy, into a
single name space \cite[chapter 7]{jls}. Packages provide a natural way
of organizing and referring to classes and methods. Significantly,
classes within a package have access rights to each other's protected
fields and methods. Each class is contained in exactly one package
(possibly the unnamed package).

In the SKVM, package access must be controlled in order to control
access to protected fields and methods (see \cite{mcgraw}, page 189).

The mechanism used in the SKVM for controlling package access has
three elements:
\begin{itemize}
  \item A package has an owner and an owner-managed key-pair,
  analogous to that used for subclassing.
  \item A package's public key is part of the package's name. If someone tries
  to put a class in a package without the right public key,
  the class will be put in a different package. The SKVM
  simply uses the public key as part of the name space
  reference.
  \item Every class is in a package. If a class does not specify a package the
  SKVM puts it in the unnamed package.
\end{itemize}

Note that the VM does not have an \emph{a priori} list of packages. The
VM first knows about a package when a class belonging to the package
is loaded (or, optionally, when installed on the device; see below).
The first loaded class defines the package to the SKVM, and any
subsequent classes belonging to the same package are checked for
consistency. It is the responsibility of all classes in a package
to identify the package identically, by name as well as public key.

There may appear to be a security weakness because classes bring
in both the package signature as well as the key with which the
signature is verified. In fact, while a malicious class could
generate a fake package key and a signature consistent with this
fake key, it would not be able to join an existing package because
it would not be able to replicate the signature associated with the
package's private key; it would instead be put in a distinct package.

The Language defines an unnamed package and assigns all classes
that do not specify a package name to this unnamed package. A class
that does not specify a package is automatically put into the unnamed
package. Any package public key specified in the trust attribute
of a class that does not specify a package name is ignored.

While the unnamed package is a convenience during code development,
a secure application built for the SKVM should specify packages for
all its classes. To encourage such a practice and to provide higher
levels of security assurance, the SKVM has a flag that, when set,
prevents the loading of any class that does not specify a package.
The SKVM by default runs with this flag cleared. Once set, the flag
cannot be cleared without restarting the SKVM.

\subsection{Interfaces}

With one notable exception, an interface specifies functionality
without providing an implementation [JLS, chapter 9]. The exception
is for static initialized fields. In such cases, the initializing
expression may contain requests to instantiate objects, which may
require SKVM privileges. It is therefore necessary to associate
privileges with an interface.

As with a class, an interface has a nominal owner. The owner is
responsible for securing all required privileges for the interface.
A trusted interface \var{X} demonstrates that it can extend a trusted
interface \var{Y} by presenting a certificate signed by \var{Y}. This certificate
is analogous to the subclassing certificate and employs the same
data structure and mechanisms.

Note that a class that implements an interface can be independently
accessed and manipulated as a class in its own right. In such cases,
normal Language semantics dictate what can be accessed.

\subsection{Inner Classes}

The Language allows the definition of inner classes as members of
other classes \cite[section 8.1.2]{jls}. These inner classes are implemented
through compiler-introduced source code transformations and appear
to the VM as distinct classfiles.

The SKVM requires a trusted inner class to present a trust attribute,
as any other trusted class would. It is the responsibility of the
owner of the trusted inner class to generate this trust attribute.
Of course, any tool that supports generation of trust attributes
may wish to facilitate the construction of attributes for inner
classes. For instance, the tool might handle all name transformations
transparently, and employ the same key-pairs for the inner class
as it employs for the outer, enclosing class.

The source code transformations introduced by the compiler to support
inner classes implement a weakening of access permissions. This is
necessary because there is no support in Java virtual machines for
direct access to a private member of a class from another class.
The specific instances of access permission weakening are:
\begin{itemize}
  \item Private inner classes are implemented as package
  level classes.
  \item Protected inner classes are implemented as public level classes.
  \item Private class members (fields or methods) that are visible between
  classes (due to the shared scoping relationship between inner and enclosing
  classes) are indirectly implemented with package level
  access. Note that sharing of private members between classes
  participating in an inner class relationship is achieved
  by a local protocol of access methods that reflect the mode
  of access expressed in the source. These methods have package
  scope and as such are open to any class within the same
  package.
\end{itemize}

Like other VMs, the SKVM cannot reliably identify inner classes and
therefore cannot determine when such access permissions have been
weakened. Therefore, developers for the SKVM platform must be aware
of these issues. The problems due to weakened access permissions
can be avoided by adopting the following guidelines:
\begin{itemize}
  \item Classes in an enclosing/inner class relationship
  should never rely on the shared scoping of their private
  members.
  \item Inner classes should never be declared	private or protected.
\end{itemize}

Following such guidelines will ensure that there is always a
one-to-one correspondence between the source level access permissions
of a class and its classfile implementation.

The use of anonymous inner classes should be avoided due to the
difficulties of managing their trust relationships.

The use of non-static inner classes should also be avoided since
they are in a sense syntactic sugar for static inner classes and
thus hide detail that makes security analysis harder.

\subsection{Exceptions and Trust Relationships}

When an exception occurs in a running program, the VM unwinds the
call stack until the most recently installed relevant exception
handler is encountered, which then catches the exception \cite[section 11.3]{jls} \cite[sections 2.16.2 and 3.10]{jvms}. The code that throws
the exception is never resumed.

There are security issues in adopting such a model directly in the
SKVM. For instance, a class could install an exception handler and,
at a later stage, a different class could throw an exception. This
second class may not enjoy any trust relationship with the first
class. As a result there is an unanticipated transfer of control
that complicates security analysis and becomes a potential
vulnerability.

Note that exceptions are simply standard objects with the additional
property that they are derived (indirectly or directly) from
\src{java.lang.Throwable}. As such, package access semantics can be
leveraged to prevent classes external to a package from catching
exceptions thrown from within the package. A non-public exception
(one whose class definition does not include the public access
modifier) is invisible to all classes outside its package and
therefore no handler in these external classes can explicitly declare
to catch exceptions.

Unfortunately, package access semantics do not completely control
exception handlers. It is legal to hold a reference to an object
even though the static type of the reference may preclude any knowledge
of the object's complete type. This can be achieved with a reference
to publicly accessible base type (such as \src{java.lang.Object}). This
means that exception handlers can catch exceptions via base class
declarations. The lowest common base class for every exception is
\src{java.lang.Throwable}. A handler declared to catch such an exception
would catch package-restricted exceptions. While Language semantics
prevent the handler's scope from using the exception as an instance
of its complete type, the mere fact that it can been caught presents
a means to mask out or alter secure control flow transfer. Thus, a
mechanism for preventing this interference is built into the SKVM.

Each class includes a flag within its trust attribute. If the flag
is cleared, then any package-restricted exception thrown by \var{X} can
only be caught by exception handlers within the same package as the
throwing class. If this flag is set in class \var{X}, then standard
exception semantics are applied when an exception is thrown by any
method in \var{X}.

Note that if all classes that potentially throw exceptions set this
flag, exception handling in the SKVM will be identical to, and
compatible with, the KVM.

\section{The Trust Attribute}

The trust attribute is a collection of data that is attached to
each trusted class and that determines its privileges. The trust
attribute is primarily composed of a number of public keys.
The use of these keys to sign and verify privileges
constitutes the crux of the SKVM. The trust attribute is understood
by the SKVM and ignored by other VMs.

With each package \var{P} there is an associated key pair (\key{PK}{P}, \key{pk}{P}),
generated by the owner of the package. With each class \var{X} there is
an associated key pair, the subclassing key pair (\key{SK}{X}, \key{sk}{X}). The
SKVM does not require that all these key-pairs be distinct. Indeed,
a key pair can be employed in multiple roles depending on the
underlying security policy that the SKVM is enforcing (subclass and
package being the same, for example).

In the following, class \var{X} belongs in package \var{P} and wishes to subclass
\var{Y}. The trust attribute for \var{X} is described in Table~\ref{tab:trust-attr}.

\begin{ctable}{tab:trust-attr}{Components of a Trust Attribute}
\begin{tabular}{| \col{0.20} | \col{0.70} |}      \hline
\key{T}{X} &  A non-negative integral timestamp indicating the time of creation
              of \var{X}. This timestamp is used for version control on
	      installation and loading, and it is assumed that newer versions
	      have larger timestamps than older versions. \\ \hline
\key{SK}{X} & The public key used for verifying attempts to subclass \var{X}. \\ \hline
\key{SH}{Y}($X|T|Cert$) & A hash of class \var{X}, its timestamp \key{T}{X},
              and all the fields in the trust attribute \emph{minus this field},
	      signed by the subclassing private key of parent class \var{Y}.
	      This hash is the signature that is used to validate the
              subclassing privilege, as well as the authenticity of the
	      classfile and the trust attribute. \\ \hline
\key{PK}{P} & The public key of the package \var{P} (if any) that \var{X}
              belongs in. This is needed for identification of packages and
	      exception processing. \\ \hline
\key{PH}{P}($X|T$) & The hash of class \var{X} and its timestamp \key{T}{X} signed
              by the private key \key{pk}{P} of package \var{P}. This signature
	      is verified with the public key \key{PK}{P} and is the means
	      by which the SKVM knows that class \var{X} belongs in package
	      \var{P}. \\ \hline
\key{EF}{X} & A constant specifying how package-private exceptions are handled
              in the face of handlers declared to catch them via publicly
	      accessible base classes. The constant takes on values {\bf yes}
	      (all classes can catch package-private exceptions thrown by this
	      class) and {\bf no} (only trusted classes in the same package as
	      the class throwing the exception can catch it). \\ \hline
\end{tabular}
\end{ctable}

The classfile described here refers to the CLDC classfile, which
includes the traditional J2SE classfile and the stack-maps generated by
the CLDC preverifier.

The timestamp above is part of the hash in order to validate the time
the class was hashed. This guarantees the integrity of versioning, which
is based on the timestamp.

A rogue class cannot use the public key of another package because it
will not be able to generate the necessary signed hash, since it does
not have access to the private key. The rogue class could generate a
separate key pair (in which case it would have the private key of that
pair), but the public keys would not match the package keys of other
classes and the class will end up in its own package. Since packages are
determined by equivalence classes defined on the relation of ``equality
of public keys'', it is not possible for a rogue class to forge admission
to a package.

The \key{EF}{X} flag in the trust attribute is designed to be fail-safe.
Specifically, the false or {\bf no} setting is the secure setting. It is
assumed that the false or {\bf no} setting is associated with the zeroed state
in the platform (typically integer 0 or Boolean False).

Now consider what happens when the SKVM receives class \var{X} and wishes to
install it. As a trusted class, \var{X} subclasses \var{Y} and should be installed
as its child. Class \var{X} demonstrates that it has this privilege by
presenting \key{SH}{Y}($X|T|Cert$). This same signature also establishes that the
owner of \var{Y} has vouched for the integrity of the contents of \var{X}. This can
be verified with \var{Y}'s subclassing public key, which can be found in \var{Y}'s
certificate. (Since \var{Y} is already installed, its certificate must have
been previously validated.)

Class \var{X} proves that it has the privilege of belonging in package \var{P} by
subjecting the signed hash \key{PH}{P}($X|T$) to verification using the public key
stored with the package. Membership in an existing package is
demonstrated by using the same package public key as an existing class.

\section{Contextual Issues}

The SKVM as described above requires certain platform support to operate
properly. In particular, classfiles stored on device must be handled
correctly, and specific cryptographic functions must be available.


\subsection{When Trust Attributes are Checked}

In general, the arrival and storage of classfiles on a device will occur
before the SKVM needs to load them (as is generally the case with CLDC
platforms). In addition, some of the new classfiles arriving on a device
may replace existing ones. These circumstances make it potentially
desirable to check trust attributes at times other than class loading.

The CLDC specification \cite[section 5.3]{cldc} gives the platform implementor
considerable freedom. The classfile lookup order is implementation
dependent and a classpath is not required. It is required that the lookup
order cannot be manipulated by the application programmer in any way.
(Note that the platform must read classfiles and JAR files \cite[section
5.3.1]{cldc}. Applications that are ``distributed publicly'' on a network open
to the public must be in JAR format. Also note that the JAR file loading
boundary required by the CLDC specification is not necessary in the
SKVM, since the SKVM uses a stronger security mechanism. Nonetheless,
the SKVM supports this boundary in strict KVM mode.)

The SKVM follows the CLDC specification and thus does not impose an
ordering or, therefore a particular time for checking trust attributes.
The earliest attributes can be checked is when classfiles arrive on a
device; the latest is when they are executed for the first time (per
application), the traditional load time).

Various issues arise that affect order considerations. First, for
devices that may install classfiles from a potentially malicious source,
buffer overflow attacks via classfiles with bogus attributes are
possible. A device could be flooded with apparently proper classfiles
that can only be flushed when their attributes are checked. Second,
newly arrived classfiles may dynamically replace a subset of the classes
in an application, which requires versioning and the rechecking of
attributes.

The way to deal with the buffer overflow problem is to check trust
attributes when classfiles arrive on the platform. Otherwise, classfiles
would have to be kept around indefinitely. Applications must therefore
be engineered to install their classes in an order that allows them to
be verified as trusted when they are installed. The burden of meeting
this constraint is on the application designer: the superclass must be
either already installed or immediately available.

One implementation of this checking is to use an arrival buffer. Classes
arriving on the device are initially put in this buffer and are moved
into classfile storage when their trust attributes are verified. JAR
files are also unpacked in this buffer. When a classfile arrives its
subclassing certificate is checked against its superclass, if extant. If
the trust attribute or superclass is absent, the classfile is flushed.
If the subclassing certificate is valid the classfile is moved to
classfile storage; otherwise it is flushed.

With respect to the versioning issue, the SKVM requires the trust
attribute of each classfile to include a time stamp. The trust attribute
checker (whenever run) inspects the time stamps, validates the newest
class, and discards the old class (or marks it as to be deleted if the
old classfile is being used by a running application).

Rechecking of attributes can be done in one of two ways. If attribute
checking is done at installation then the installation of a replacement
class in turn requires that classes granted privileges by it must be
rechecked, if anything in its attribute has changed. If checking is
done dynamically, then no extra processing is necessary. (Note that
binary compatibility is important but is not an SKVM issue; it is rather
handled by the VM in due course.)


\subsection{Cryptographic Support}
\label{crypto-support}

The SKVM requires cryptographic support to enforce security.
Specifically, it requires two functions, one for digital signature
support and one for cryptographic hash computation. The SKVM provides
basic implementations of these functions, but allows deployment of
custom versions.

The basic functions are RSA with a 1024-modulus key as the signature
algorithm, and MD5 as the cryptographic hash function. RSA is a public
key algorithm. It operates by creating two keys, a public key and a
private key. As the names suggest, the private key is kept private and
used for signing certificates while the public key is made known to
everyone for verifying certificate signatures. MD5 is a collision-free
message digest, or hash function. It computes a 128-bit hash value of an
array of data.

Note that RSA is a \emph{de facto} standard and has the advantage of very rapid
signature verification times. However, this is at the expense of rather
large signatures. This is not an issue for the subclass privilege, which
is verified only on class loading and can be discarded afterwards.
However, instantiation certificates (described in Section~\ref{crypto-support})
have to be maintained in the VM, and each such certificate requires 1024 bits
(128 bytes) of storage.

If standard RSA certificate size is found to be unacceptable, either
elliptic-curve RSA, which is secure with approximately 155bits ($\approx$ 20
bytes), or DSA, for which the signatures are $2 \times 160 = 320 bits$ (40 bytes),
can be employed. However, there is a (running time) performance penalty
in the use of either ECC or DSA. In addition, DSA optimizes signing at
the expense of verification and can be up to 100 times slower than RSA.

Message Authentication Codes (MAC) are an alternative to public key
based hash-and-sign signatures. While MACs are considerably less
demanding in terms of storage and computation time, a MAC requires a
symmetric secret key. The use of MACs should be avoided because they
make SKVM integrity depend on secrets internal to the SKVM, violating
the precept against secrecy. Additionally, they require infrastructure
for the storage and management of secret keys, and require the secure
transmission of classfiles (since keys appear in the clear in the trust
attribute). Nevertheless, the choice remains with the platform owner.

Platform owners can integrate custom signature and hash algorithms into
the SKVM. However, for security reasons, these must be integrated at the
VM level, and not at the class level, in keeping with the precept of
static specification.

Note that the SKVM architecture does not specify how subclassing and
instantiation verification keys are to be managed. Nor does it stipulate
how the system protects itself against other forms of attack on public
key systems such as spoofing and man-in-the-middle. Such issues depend
on the requirements of the application and the trusted community. Note
however that since all keys are public keys (unless MACs are used),
confidentiality is not required and there is therefore no need to store
secrets. All that is required is that the keys be authentic, and the
mechanism by which classfiles are loaded ensures this.

\subsection{Security-Related Exceptions}


The SKVM throws an exception when a privilege verification fails.
Depending on the circumstances, \src{IllegalSubclassException} or
\src{IllegalPackageException} is thrown by the VM when a privilege certificate
could not be verified successfully. When the VM throws one of these
exceptions it uses an instance created at VM startup. Establishing
whether or not an exception being propagated resulted from a security
violation is thus reduced to a simple object pointer comparison.


\subsection{SKVM Applications and Their Development}


SKVM applications are CLDC applications: programs with a main method
\cite[section 3.2]{cldc}. An application's component classes are loaded when
necessary. When the class containing the main method is loaded, the
application is registered and is then run. Class loading is controlled
by the security mechanisms described above.

The SKVM employs a Java Application Manager, or JAM, similar to JAMs
used with the KVM. The JAM assumes that there is local storage
(typically a file system or a local database) that stores installed
classes and from which classes can be loaded. The SKVM architecture does
not require that the complete application be resident -- components may
be loaded dynamically over a communication channel -- although an
implementation may impose this restriction. The JAM starts the SKVM and
indicates to it which application (which classfile with a main method)
should be run.

For the purposes of defining trusted communities and establishing the
initial trust relationships, the CLDC library can be thought of as owned
by the platform. Applications wishing to execute on the platform will
have to request and obtain privileges to subclass the CLDC library.

If the platform is one of many being issued by an authority (such as a
payment token being issued by a credit card company) then all platforms
may share a common CLDC owner and hence have identical subclassing and
instance-creation public keys.

For development purposes, a platform authority can release a version of
the platform with a different CLDC signing key-pair created purely for
application development, with the private key released to developers.
This allows the developers to sign their classes each time they are
changed, without having to request the authority to do so. When the
application is complete, it is installed on the production platform with
a different set of keys, with the CLDC signing key kept private.

The SKVM architecture does not support multiple applications running in
the same virtual machine. The goal of such support is to protect
applications from each other to a degree comparable with process
isolation on a standard operating system, less protection than the SKVM
aims to provide.

The KVM supports the KVM Debug Wire Protocol \cite{kdwp}, a debugging
protocol that is a subset of the JDWP standard. The SKVM implements the
KDWP, but only during debugging. It obviously must be removed for
deployment. The KDWP may be enhanced to display the additional
information present in the SKVM, such as that pertaining to trusted and
untrusted space.

The security support in the SKVM is enabled by configuration settings.
Given fail-safe design principles, these settings default to secure
modes. However, they can be set so that all security features in the
SKVM visible to developers are disabled, with the result that the SKVM
is identical in function to the KVM.

For backward compatibility, the SKVM can be initiated in strict KVM
mode. In this mode, SKVM security features are disabled. Trust
attributes are not required for any of the classes. Strict KVM mode is
enabled if the class containing the main method has no security
attribute. The KVM default restriction that all classes in an
application be in a single JAR file is enforced in strict KVM mode \cite[section 3.4.2.3]{cldc}.

\section{Additional Optional Functionality in the Trust Attribute}

The trust attribute mechanism presented above can be extended with
additional information to support other, optional, security-related
features besides dynamic provisioning. The specific extensions explored
in the SKVM involve implementing a form of capability-based control and
enabling limited execution of untrusted classes.

\subsection{Support for Capability-Oriented Design}

Good object-oriented and secure programming practice mandates the
factoring and encapsulation of data. This factoring enables a
capability-based style of programming \cite{dennis}, in which a capability is
represented by an object, and references to that object are controlled.
Ideally, all references to a capability object would be monitored, and
unauthorized uses prevented, but the overhead of checking all references
is too great.

A simpler (and less secure) mechanism can be constructed to control the
creation of objects (as capabilities) and references to static fields
and methods. With this compromise scheme, the creation of capabilities
is monitored but their use is not. Class-based references are also
monitored.

This mechanism has been implemented in the SKVM via another trust
attribute privilege: the privilege to create a new instance of (that is,
instantiate) an object and reference its static methods and fields. This
privilege is referred to as the {\bf A} (``access'') privilege, with the sense
of accessing the resources of a class. There are two implicit
instantiation privileges granted for a given class \var{X}. The first is
(trivially) granted to \var{X} itself and the second is granted to the
superclasses of \var{X}.

\subsection{Domains}

In practice the access privilege can be burdensome to administer. A
collection of classes may want to share the privilege to access one
another's class resources (instantiation and access to static methods
and fields), especially if the classes have been developed together,
provide a coherent module of functionality, or are within a shared
security perimeter. To reduce the burden of maintaining individual class
access privileges, the SKVM supports domains.

A domain privilege is shared among a group of classes in a domain and
allows each class to instantiate all other classes in the domain and
reference their static methods and fields. With domains, individual
access privileges for each class are no longer required. A class may be
in only one domain. Domains, reflecting security concerns only (as
opposed to name space issues), are distinct from packages, but may be
made coincident with them.

Typically, domains allow groups of classes that reference each other
frequently (whether through instantiation or static method or field
access) to do so without needing to verify access privileges each time.
Such privilege verification involves verifying a signature against a
public key and can be costly in execution time as well as memory (to
store the signature). With domains, an inter-class resource access is
permitted as long as the domain membership keys of the accessing and
accessed class are equal. In this way, domains simplify application
design, application development, and SKVM implementation.

\subsection{Additions to the Trust Attribute to Support Capabilities}

With each class \var{X} there is the associated class resource access key pair
(\key{AK}{X}, \key{ak}{X}).

With each domain \var{D} there is an associated key pair (\key{DK}{D},
\key{dk}{D}) generated by the owner of the domain.

Consider a class \var{X} that belongs in package \var{P} and domain \var{D} and wishes
to access the resources in class \var{Z} (not in domain \var{D}). The additional
components of the trust attribute for \var{X} relating to capabilities for
this type of access are described in Table~\ref{tab:cap-trust-attr}.

\begin{ctable}{tab:cap-trust-attr}{Components of a Trust Attribute for supporting Capabilities}
\begin{tabular}{| \col{0.2} | \col{0.7} |}      \hline
\key{AK}{X}        & A public key used to verify access requests to the resources of class \var{X}. \\ \hline
\key{AH}{Z}($X|T$) & A hash of class \var{X} and its timestamp \key{T}{X} signed by the class resource
                     access private key of class \var{Z}. This signature is verified with the
                     public key \key{AK}{Z}. Note that there are as many hashes of the form
                     \key{AH}{Z}($X|T$) as there are resources that \var{X} needs to access
                     from different classes. \\ \hline
\key{DK}{D}        & The public key of the domain \var{D} that \var{X} belongs in. This key determines
                     the identity of the domain. \\ \hline
\key{DH}{D}($X|T$) & The hash of class \var{X} and its timestamp \key{T}{X} signed by the private key \key{dk}{D}
                     of domain \var{D}. This signature is verified with the public key \key{DK}{D}
                     and is the means by which the SKVM knows that class \var{X} belongs in
                     domain \var{D}. \\ \hline
\end{tabular}
\end{ctable}

If class \var{X} now wishes to create an instance of class \var{Z}, it demonstrates
that it has this privilege by having the signed hash \key{AH}{Z}($X|T$), which can
be verified with \key{AK}{Z}, the public key found in \var{Z}'s certificate.

Class \var{X} proves that it has the privilege of belonging in domain \var{D} by
subjecting the signed hash \key{DH}{D}($X|T$) to verification using the public key
stored with the domain. Membership in an existing domain is demonstrated
by using the same domain public key as an existing class.

The ability to subclass or to create an object implies the ability to
subclass or create any parent of the object as part of the act of
subclassing or creating the object. These are standard Language rules.
Note however that the ability to subclass or instantiate an object does
not imply the ability to subclass or instantiate any parent of the
object in the class hierarchy independently. The operation (subclassing
or instantiation) on the parent of the class in question can only happen
as a direct and automatic result of the same operation on the class
itself. For example, if class \var{X} has permission to instantiate class \var{B},
which subclasses \var{A}, then it does not necessarily follow that \var{X} could
directly instantiate \var{A}. To do so requires that \var{X} have explicit
permission for instantiation from \var{A}.

As with packages, a rogue class cannot use the public key of another
domain because it will not be able to generate the necessary signed
hash, since it does not have access to the private key. The rogue class
could generate a separate key pair (in which case it would have the
private key of that pair), but the public keys would not match the
domain keys of other classes and the class will end up in its own
domain. Since domains are determined by equivalence classes defined on
the relation of ``equality of public keys'', it is not possible for a
rogue class to forge admission to a domain.

\subsection{Loading and Executing Untrusted Classes}

Untrusted classes are ones without any trust attributes (as
distinguished from classes with invalid trust attributes, which are
mistrusted). Such classes can provide useful, CLDC-standard
functionality if their execution is strictly controlled.

In the SKVM this is done by keeping untrusted classes in a sandbox and
allowing trusted classes to grant privileges to untrusted ones. The
degree to which trusted classes are prepared to grant privileges to
untrusted classes defines the extent of the sandbox; the sandbox is not
fixed or defined \emph{a priori}.

\subsection{Untrusted Classes and Privileges}

Untrusted classes rely on trusted classes for all their privileges.
Since untrusted classes have no certificates, from a security standpoint
they are indistinguishable from one another. Privileges are granted
uniformly to all untrusted classes. These privileges take three forms:

\begin{itemize}
  \item An untrusted class may be allowed to subclass a trusted class.
  Like all other privileges granted to untrusted classes, this is a
  privilege that the trusted class in question must grant explicitly.
  \item In the capability-based style discussed above, and similar to a
  trusted class, an untrusted class may be granted the privilege to
  create a new instance of a trusted class. Again, this is a
  privilege that is explicitly granted by a trusted class to all
  untrusted classes uniformly.
  \item An untrusted class may be granted or denied the power to call a
  trusted method (usually static) or access a trusted field. This
  power is in addition to the Language's standard access control
  mechanisms, and is necessary for historical reasons.
\end{itemize}

Privileges granted to untrusted classes are specified with flags in the
trust attribute of the trusted class. In addition, flags associated with
each method and field in the trusted class indicate whether the method
can be called from, or the field accessed from, an untrusted class. This
enables an application to run untrusted classes written to the standard
CLDC API while retaining some measure of control.

It would be simpler to have a flag that indicated whether all methods
and fields in a trusted class could be accessed from untrusted classes.
This would be sufficient if the trusted aspects of an application were
well factored into specific trusted classes. Although most of the CLDC
library can be handled with such a flag, there are cases in CLDC that
break this principle. It is in general desirable from a security
factorization standpoint that SKVM applications be designed to use
class-level security rather than relying on method-level or field-level
control.

There have been attempts in the various releases of the Language to
enumerate which functions in the core libraries are exposed to sandboxed
classes. The flag mechanism provides a means by which such selective
exposure can be accomplished. The flag mechanism also provides control
over static methods and fields in classes like \src{java.lang.System} that cannot be
instantiated. This is important since untrusted classes may need access
to some fields and methods (such as \src{java.lang.System.out}) while other fields and
methods (such as \src{java.lang.System.exit}) should not be accessible.

\subsection{Additions to the Trust Attribute to Support Untrusted Classes}

For a class \var{X}, Table~\ref{tab:utc-trust-attr} describes the additional
components of the trust attribute that relate to untrusted classes.

\begin{ctable}{tab:utc-trust-attr}{Components of a Trust Attribute for supporting Untrusted Classes}
\begin{tabular}{| \col{0.2} | \col{0.7} |}      \hline
\key{SF}{X}       & A binary flag indicating if objects can subclass \var{X} without privileges.
                    If the flag is false, then untrusted classes cannot subclass \var{X} and
                    trusted classes need to present the appropriate certificate (signed
                    hash) in order to subclass \var{X} successfully. If the flag is true, then all
                    classes can subclass \var{X} as long as Language semantics are obeyed. \\  \hline
\key{NF}{X}       & A flag specifying if objects can instantiate \var{X} without privilege. If the
                    flag is false, then an object can only instantiate \var{X} by presenting the
                    appropriate certificate. If the flag is true, then all classes can
                    instantiate \var{X} as long as Language semantics are obeyed. \\ \hline
\key{MF}{X}       & A constant specifying if all objects can invoke static methods in \var{X}. The
                    constant takes on values {\bf yes} (all static methods in \var{X} can be invoked by
                    any object, subject to standard Language semantics), {\bf no} (static methods
                    in \var{X} can only be invoked by an object that presents the appropriate
                    certificate), and {\bf byMethod} (flags associated with each static method
                    determine if the method can be invoked without privilege). \\ \hline
\key{FF}{X}       & A constant specifying if all objects can access static fields in \var{X}. The
                    constant takes on values {\bf yes} (all static fields in \var{X} can be accessed by
                    any object, subject to standard Language semantics), {\bf no} (static fields
                    in \var{X} can only be accessed by an object that presents the appropriate
                    certificate), and {\bf byField} (flags associated with each static field
                    determine if the field can be accessed without privilege). \\ \hline
\end{tabular}
\end{ctable}

These flags are designed to be fail-safe. Specifically, the false or {\bf no}
setting of the \key{SF}{X}, \key{NF}{X}, \key{MF}{X}, and \key{FF}{X} flags are secure settings. It is
assumed that the false or no setting is associated with the zeroed state
in the platform (typically integer 0 or Boolean False).

\section{Implementation}

A version of the SKVM has been implemented using the KVM code base
version 1.03. The implementation includes basic support for secure
dynamic provisioning, support for capabilities, and support for
untrusted classes.

In general, changes to the KVM were small and localized.

Note that support for capabilities and untrusted classes involves extra
runtime checks and thus incurs a performance penalty. This penalty was
not measured.

\subsection{Secure Dynamic Provisioning}

Seven files (out of 24) required modification, and one small file was
added. The details of these changes are shown in Table~\ref{tab:sdp-overhead}.
The total increase in size, in lines of code, is 4\%.

\begin{ctable}{tab:sdp-overhead}{Code size overhead of Secure Dynamic Provisioning}
\begin{tabular}{| \lcol | \rcol | \rcol | \rcol |}     \hline
File         & LoC in base KVM & Additional LoC for SKVM  & \% Increase \\ \hline\hline
class.c      & 1985            & 216                      & 11\%        \\ \hline
collector.c  & 2096            & 54                       & 3\%         \\ \hline
crypto.c     & 0               & 124                      & 100\%       \\ \hline
frame.c      & 1149            & 6                        & 1\%         \\ \hline
hashtable.c  & 718             & 76                       & 11\%        \\ \hline
loader.c     & 2957            & 381                      & 13\%        \\ \hline
nativeCore.c & 1287            & 12                       & 1\%         \\ \hline
pool.c       & 437             & 46                       & 11\%        \\ \hline
\emph{total} & \emph{23759}    & \emph{915}               & \emph{4\%}  \\ \hline
\end{tabular}
\end{ctable}

This increase consists of enhancements to: identify and process trusted
classes (loader); manage certificates (hashtable), privileges
(collector), and other runtime structures (crypto); perform privilege
checks (class, nativeCore, and pool); and handle exceptions (frame).

Additionally, a stand alone tool was written to annotate classfiles with
properly constructed trust attributes.

\subsection{Capabilities}

Support for capabilities pushed the total code size increase to 6, to a total
of 24272 lines. The details of these changes are shown in
Table~\ref{tab:cap-overhead}.

\begin{ctable}{tab:cap-overhead}{Code size overhead of Capabilites}
\begin{tabular}{| \lcol | \rcol |}  \hline
File     & Additional LoC for Capabilities \\ \hline\hline
class.c  & 243  \\ \hline
frame.c  & 4    \\ \hline
loader.c & 266  \\ \hline
\end{tabular}
\end{ctable}

This further increase consists of enhancements to: process the
capability-based privileges (loader); handle domain intersection and
resource access checks (class); and handle exceptions (frame).

\subsection{Untrusted Classes}

Support for untrusted classes bumped the total code size increase to 7, to
a total of 24538 lines.

\begin{ctable}{tab:utc-overhead}{Code size overhead of Untrusted Classes}
\begin{tabular}{| \lcol | \rcol |} \hline
File     & Additional LoC for Untrusted Classes \\ \hline\hline
loader.c & 171  \\ \hline
pool.c   & 95   \\ \hline
\end{tabular}
\end{ctable}

This final increase consists of enhancements to: process the untrusted
class privileges (loader); and handle access checks (pool). The details
of these changes are shown in Table~\ref{tab:utc-overhead}.

\section{Status and Further Work}

As described above, a prototype version of the SKVM has been implemented
based on the standard KVM. There are other, more recent CLDC
implementations that are potentially better platforms on which to base
the SKVM (such as \cite{shaylor}). Further work with the SKVM will likely be done
using one of these implementations.

The next major step in demonstrating the feasibility and value of the
SKVM will be porting it to a cryptographic module. This task may expose
platform and deployment issues. It will also enable real-world testing
of SKVM applications.

The subsequent step will be the FIPS certification of the SKVM. This
effort will require precise definition of the operation and
implementation of the SKVM.

A possible enhancement involves untrusted classes. If it is determined
that they are truly useful on a secure platform, they can be completely
isolated in their own execution environment \cite{doorn}. They could be given
their own heap, execution stack, and resource limits.

%
% ---- Bibliography ----
%
\begin{thebibliography}{99}
%
\bibitem{cldc}
\emph{Connected, Limited Device Configuration, Specification Version 1.1};
Sun Microsystems, May 2002;
\url{http://java.sun.com/products/cldc}.

\bibitem{fips}
\emph{Security Requirements for Cryptographic Modules};
NIST FIPS PUB 140-2, 25 May 2001.

\bibitem{j2ps}
\emph{Inside Java 2 Platform Security};
Li Gong;
Addison-Wesley; October 1999.

\bibitem{javacard}
\emph{Java Card Technology for Smart Cards};
 Zhiqun Chen;
 Addison-Wesley; June 2000.

\bibitem{jls}
\emph{The Java Language Specification, Second Edition};
James Gosling, Bill Joy, Guy Steele, Gilad Bracha;
Addison-Wesley, June 2000.

\bibitem{jvms}
\emph{The Java Virtual Machine Specification, Second Edition};
Tim Lindholm, Frank Yellin;
Addison-Wesley, April 1999.

\bibitem{kdwp}
\emph{KVM Debug Wire Protocol (KDWP), Version 1.0};
Sun Microsystems;
26 February 2001.

\bibitem{kvm}
Information on the KVM can be found at \url{http://java.sun.com/products/cldc}.

\bibitem{midp}
\emph{Mobile Information Device Profile for Java 2 Micro Edition, Version 2.0};
Java Community Process, November 2002;
\url{http://java.sun.com/products/midp}.

\bibitem{tck}
\emph{CLDC Technology Compatibility Kit version 1.0a User's Guide};
Sun Microsystems;
February 2001.

\bibitem{kolsi}
``MIDP 2.0 Security Enhancements'';
Otto Kolsi, Teemupekka Virtanen;
\emph{Proceedings of the 37th Annual Hawaii International Conference on System Sciences (HICSS'04)};
January 2004.

\bibitem{knudsen}
``Understanding MIDP 2.0's Security Architecture'';
Jonathan Knudsen;
February 2003;
\url{http://developers.sun.com/techtopics/mobility/midp/articles/permissions/}

\bibitem{acharya}
``MAPbox: Using Parameterized Behavior CLasses to Confine Untrusted Applications'';
Anurag Acharya, Mandar Raje;
\emph{Proceedings of the 9th USENIX Security Symposium};
August 2000.

\bibitem{peterson}
``A Flexible Containment Mechanism for Executing Untrusted Code'';
David S. Peterson, Matt Bishop, Raju Pandey;
\emph{Proceedings of the 11th USENIX Security Symposium};
August 2002.

\bibitem{dyer}
\emph{Building the IBM 4758 Secure Coprocessor};
Joan G. Dyer, Mark Lindemann, Ronald Perez, Reiner Sailer, Leendert van Doorn, Sean W. Smith, Steve Weingart;
IEEE Computer;
October 2001; pp. {\bf 57-66}.

\bibitem{schneier}
\emph{Secrets and Lies};
Bruce Schneier;
John Wiley and Sons, 2000.

\bibitem{schneier96}
\emph{Applied Cryptography, Second Edition};
Bruce Schneier;
John Wiley and Sons; 1996.

\bibitem{anderson}
\emph{Security Engineering: A Guide to Building Dependable Distributed Systems};
Ross Anderson;
John Wiley and Sons; 2001.

\bibitem{mcgraw}
\emph{Securing Java};
Gary McGraw, Edward W. Felten;
John Wiley and Sons, 1999.

\bibitem{dennis}
``Programming Semantics for Multiprogrammed Computations'';
Jack Dennis, Earl Van Horn;
\emph{Communications of the ACM};
March 1966; pp. {\bf 143-155}.

\bibitem{shaylor}
``A Java Virtual Machine Architecture for Very Small Devices'';
Nik Shaylor, Doug Simon, Bill Bush;
\emph{Proceedings of the 2003 ACM SIGPLAN conference on Languages, Compilers, and Tools for Embedded Systems}, June 2003, pp. {\bf 34-41}.

\bibitem{doorn}
``A Secure Java Virtual Machine'';
Leendert van Doorn;
\emph{Proceedings of the 9the USENIX Security Symposium};
August 2000.

\end{thebibliography}
\end{document}
